Topic_no,Keywords,Contrib,System,Text
0,"time_taken, user, batch_size, test, implementation, bit, result, us_mqps, hash_function, full, performance, count, size_time, functions_time, items_utilization, number_hash, improvement, hash, insert, pass",0.05,conscrypt,auto import from
,,0.05,conscrypt,auto import from
,,0.05,conscrypt,auto import import from
,,0.05,conscrypt,auto import from
,,0.05,conscrypt,auto import from
,,0.05,conscrypt,auto import from
,,0.05,conscrypt,auto import from
,,0.0577,conscrypt,Expose CT through libcore NetworkSecurityPolicy Bug: 28746284 Change-Id: I6549a997823b38dc256911a66ac558c90bf6f762/
,,0.05,conscrypt,Various fixes to the Conscrypt engine. (#201)/
,,0.05,conscrypt,Add server certificate SNI support (#712)/
,,0.05,conscrypt,Add server certificate SNI support (#712)/
,,0.05,Frostwire,[dekstop] Using Mp4Demuxer in yt download/
,,0.05,Frostwire,[android] more player code cleanup./
,,0.05,Frostwire,[android] more player code cleanup./
,,0.05,Frostwire,[android] more player code cleanup./
,,0.05,Frostwire,[android] more player code cleanup./
,,0.05,Frostwire,[android] more player code cleanup./
,,0.05,Frostwire,[android] more player code cleanup./
,,0.05,Frostwire,[android] more player code cleanup./
,,0.0689,Frostwire,[android] Not using apache FileUtils for scan files/
,,0.05,Frostwire,[android] apollo cleanup/
,,0.05,Frostwire,[android] WIP on a NumberPickerPreference/
,,0.063,Frostwire,[Common] Fixed Monova Search Results/
,,0.05,Frostwire,[android] NPE fix on DragSortListView.measureItemAndGetHeights()/
,,0.05,Frostwire,[desktop] more azureus cleanup/
,,0.05,Frostwire,[common] fixed YT regex/
,,0.0906,Frostwire,[desktop] fix issue of listening to IPv6 and random port from settings/[desktop] minor cleanup in NetworkInterfacePaneItem/
,,0.1911,Frostwire,"[desktop] fix issue of listening to IPv6 and random port from settings/[desktop] using explicitly a random number for listening port, using zero was choosing a different random port for each pair of interface and protocol/"
,,0.05,Frostwire,[desktop] import cleanup/
,,0.05,Frostwire,[common] fixed SC/
,,0.05,Frostwire,[common] fixed SC/
,,0.05,Frostwire,"[android] lambda refactor, import cleanup/"
,,0.05,Frostwire,"[android] lambda refactor, import cleanup/"
,,0.05,Frostwire,[android] ANR on TransferDetailFilesFragment/
,,0.05,Frostwire,[desktop] CMYKJPEGImageReader cleanup/
,,0.05,Frostwire,[android] mopub interstitial loading bugfix/
,,0.05,Frostwire,[android] fix ANR on PromotionsAdapter loading mopub view/
,,0.05,Frostwire,[desktop] G+ cleanup/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.05,Frostwire,[desktop] code cleanup/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0664,Frostwire,[desktop] enforce immutability where possible/
,,0.0664,Frostwire,[desktop] code formatting/
,,0.0686,Frostwire,[desktop] enforce immutability where possible/
,,0.0686,Frostwire,[desktop] code formatting/
,,0.0652,Frostwire,[android] fixes timer unsubscription issues in TransfersFragment/
,,0.0625,Frostwire,"[android] fix buggy behavior of PromotionsAdapter, simply offer ad removal everytime/"
,,0.05,javacpp,Initial commit/
,,0.05,javacpp,Initial commit/
,,0.05,javacpp,Initial commit/
,,0.05,javacpp,Initial commit/
,,0.05,javacpp,Initial commit/
,,0.05,javacpp,Initial commit/
,,0.05,javacpp,Initial commit/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0807,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.0849,javacpp,* Throw `OutOfMemoryError` on `allocateArray()` for `Pointer` of primitive types with `size > 0 && address 0`/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.0998,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.1019,javacpp,Throw more information when `OutOfMemoryError` occurs on `allocateArray()` for `Pointer` of primitive types/
,,0.05,jna,Fix NPE git-svn-id: 2f8a963e-d2e4-e7d0-97bf-ccb7fcea9d80/
,,0.05,OpenDDS,BranchChangeLogTag: Fri Jun 19 22:14:25 UTC 2009 Adam Mitz
,,0.05,OpenDDS,Mon Jul 18 13:35:36 UTC 2011 Paul Calabrese
,,0.05,OpenDDS,ChangeLogTag: Fri Feb 10 20:49:54 UTC 2012 Adam Mitz
,,0.05,OpenDDS,Wed Aug 27 16:57:49 UTC 2014 Byron Harris
,,0.05,OpenDDS,ChangeLogTag: Wed Jan 28 18:24:36 UTC 2015 Peter Oschwald
,,0.05,pljava,GCJ bug
,,0.1068,pljava,"Handle PostgreSQL 8.1+ roles correctly. At least, cover the cases that obviously mess up in execution of deployment descriptors. This represents an executive decision that PG 8.1 is no longer supported./"
,,0.11199999999999999,pljava,"Handle PostgreSQL 8.1+ roles correctly. At least, cover the cases that obviously mess up in execution of deployment descriptors. This represents an executive decision that PG 8.1 is no longer supported./"
,,0.0837,pljava,"Add large object truncate and 64-bit offsets. PG 8.3 introduced inv_truncate, and 9.3 made offsets/lengths 64 bit. Whats nice is that the Java and JNI method signatures have always been 64-bit ready; now just stop downcasting to 32 on 9.3+ PostgreSQLs where 64 bit offsets are really accepted./"
,,0.0616,realm-java,Added count*() and lookup() methods currently without tests/
,,0.05,realm-java,Milesonte1/
,,0.1153,realm-java,"Add cause to RealmMigrationNeededException (#3482)/Remove deprecated constructor + add directory() (#3357) This commit simplifies the RealmConfiguration constructors and also ensures that we always have an Android context. It does so by now only having the`RealmConfiguration.Builder(context)` constructor. Custom file locations are now supported through the `directory()` builder method. This also made it possible to simply `assetFile(Context, location)` to only `assetFile(location)`. Having the Context means that we are now able to access system services and other framework classes without exposing any Android functionality in any potential interface (which will be needed to support Realm on the JVM)./Add RealmFileException to replace RealmIOException and IncompatibleLockFileException. Also it is mapped to the same name exception in ObjectStore to give user a detailed kind of file exception./"
,,0.05,realm-java,Fix native crash in DynamicRealmObject#setList() (#3550)/
,,0.05,realm-java,Fix native crash in DynamicRealmObject#setList() (#3550)/
,,0.0795,realm-java,Support Partial Sync (#5359) * Add preview support for partial sync/Remove ObjectServerUser (#5020) * remove ObjectServerUser * add multiple session tests * Add regression test for old SyncUser JSON * Using identity with authURL to identity a SyncUser/
,,0.05,rocksdb,Rename leveldb to rocksdb in C api/
,,0.7070000000000001,rocksdb,"Fix compaction bug in Cuckoo Table Builder. Use kvs_.size() instead of num_entries in FileSize() method. Summary: Fix compaction bug in Cuckoo Table Builder. Use kvs_.size() instead of num_entries in FileSize() method. Also added tests. Test Plan: make check all Also ran db_bench to generate multiple files. Reviewers: sdong, ljin Reviewed By: ljin Subscribers: leveldb Differential Revision: Cuckoo Table Reader performance. Inlined hash function and number of buckets a power of two. Summary: Use inlined hash functions instead of function pointer. Make number of buckets a power of two and use bitwise and instead of mod. After these changes, we get almost 50% improvement in performance. Results: With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.231us (4.3 Mqps) with batch size of 0 Time taken per op is 0.229us (4.4 Mqps) with batch size of 0 Time taken per op is 0.185us (5.4 Mqps) with batch size of 0 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.108us (9.3 Mqps) with batch size of 10 Time taken per op is 0.100us (10.0 Mqps) with batch size of 10 Time taken per op is 0.103us (9.7 Mqps) with batch size of 10 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.101us (9.9 Mqps) with batch size of 25 Time taken per op is 0.098us (10.2 Mqps) with batch size of 25 Time taken per op is 0.097us (10.3 Mqps) with batch size of 25 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.100us (10.0 Mqps) with batch size of 50 Time taken per op is 0.097us (10.3 Mqps) with batch size of 50 Time taken per op is 0.097us (10.3 Mqps) with batch size of 50 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.102us (9.8 Mqps) with batch size of 100 Time taken per op is 0.098us (10.2 Mqps) with batch size of 100 Time taken per op is 0.115us (8.7 Mqps) with batch size of 100 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.201us (5.0 Mqps) with batch size of 0 Time taken per op is 0.155us (6.5 Mqps) with batch size of 0 Time taken per op is 0.152us (6.6 Mqps) with batch size of 0 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.089us (11.3 Mqps) with batch size of 10 Time taken per op is 0.084us (11.9 Mqps) with batch size of 10 Time taken per op is 0.086us (11.6 Mqps) with batch size of 10 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.087us (11.5 Mqps) with batch size of 25 Time taken per op is 0.085us (11.7 Mqps) with batch size of 25 Time taken per op is 0.093us (10.8 Mqps) with batch size of 25 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.094us (10.6 Mqps) with batch size of 50 Time taken per op is 0.094us (10.7 Mqps) with batch size of 50 Time taken per op is 0.093us (10.8 Mqps) with batch size of 50 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.092us (10.9 Mqps) with batch size of 100 Time taken per op is 0.089us (11.2 Mqps) with batch size of 100 Time taken per op is 0.088us (11.3 Mqps) with batch size of 100 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.154us (6.5 Mqps) with batch size of 0 Time taken per op is 0.168us (6.0 Mqps) with batch size of 0 Time taken per op is 0.190us (5.3 Mqps) with batch size of 0 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.081us (12.4 Mqps) with batch size of 10 Time taken per op is 0.077us (13.0 Mqps) with batch size of 10 Time taken per op is 0.083us (12.1 Mqps) with batch size of 10 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.077us (13.0 Mqps) with batch size of 25 Time taken per op is 0.073us (13.7 Mqps) with batch size of 25 Time taken per op is 0.073us (13.7 Mqps) with batch size of 25 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.076us (13.1 Mqps) with batch size of 50 Time taken per op is 0.072us (13.8 Mqps) with batch size of 50 Time taken per op is 0.072us (13.8 Mqps) with batch size of 50 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.077us (13.0 Mqps) with batch size of 100 Time taken per op is 0.074us (13.6 Mqps) with batch size of 100 Time taken per op is 0.073us (13.6 Mqps) with batch size of 100 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.190us (5.3 Mqps) with batch size of 0 Time taken per op is 0.186us (5.4 Mqps) with batch size of 0 Time taken per op is 0.184us (5.4 Mqps) with batch size of 0 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.079us (12.7 Mqps) with batch size of 10 Time taken per op is 0.070us (14.2 Mqps) with batch size of 10 Time taken per op is 0.072us (14.0 Mqps) with batch size of 10 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.080us (12.5 Mqps) with batch size of 25 Time taken per op is 0.072us (14.0 Mqps) with batch size of 25 Time taken per op is 0.071us (14.1 Mqps) with batch size of 25 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.082us (12.1 Mqps) with batch size of 50 Time taken per op is 0.071us (14.1 Mqps) with batch size of 50 Time taken per op is 0.073us (13.6 Mqps) with batch size of 50 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.080us (12.5 Mqps) with batch size of 100 Time taken per op is 0.077us (13.0 Mqps) with batch size of 100 Time taken per op is 0.078us (12.8 Mqps) with batch size of 100 Test Plan: make check all make valgrind_check make asan_check Reviewers: sdong, ljin Reviewed By: ljin Subscribers: leveldb Differential Revision: a cache friendly version of Cuckoo Hash Summary: This implements a cache friendly version of Cuckoo Hash in which, in case of collission, we try to insert in next few locations. The size of the neighborhood to check is taken as an input parameter in builder and stored in the table. Test Plan: make check all cuckoo_table_{db,reader,builder}_test Reviewers: sdong, ljin Reviewed By: ljin Subscribers: leveldb Differential Revision:"
,,0.8432,rocksdb,"use GetContext to replace callback function pointer Summary: Intead of passing callback function pointer and its arg on Table::Get() interface, passing GetContext. This makes the interface cleaner and possible better perf. Also adding a fast pass for SaveValue() Test Plan: make all check Reviewers: igor, yhchiang, sdong Reviewed By: sdong Subscribers: leveldb Differential Revision: add one option to allow identity function for the first hash function Summary: MurmurHash becomes expensive when we do millions Get() a second in one thread. Add this option to allow the first hash function to use identity function as hash function. It results in QPS increase from 3.7M/s to ~4.3M/s. I did not observe improvement for end to end RocksDB performance. This may be caused by other bottlenecks that I will address in a separate diff. Test Plan: ``` rocksdb] ./cuckoo_table_reader_test Test CuckooReaderTest.WhenKeyExists Test CuckooReaderTest.WhenKeyExistsWithUint64Comparator Test CuckooReaderTest.CheckIterator Test CuckooReaderTest.CheckIteratorUint64 Test CuckooReaderTest.WhenKeyNotFound Test CuckooReaderTest.TestReadPerformance With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.272us (3.7 Mqps) with batch size of 0, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.138us (7.2 Mqps) with batch size of 10, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.142us (7.1 Mqps) with batch size of 25, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.142us (7.0 Mqps) with batch size of 50, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.144us (6.9 Mqps) with batch size of 100, of found keys 125829120 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.201us (5.0 Mqps) with batch size of 0, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.121us (8.3 Mqps) with batch size of 10, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.123us (8.1 Mqps) with batch size of 25, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.121us (8.3 Mqps) with batch size of 50, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.112us (8.9 Mqps) with batch size of 100, of found keys 104857600 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.251us (4.0 Mqps) with batch size of 0, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.107us (9.4 Mqps) with batch size of 10, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.099us (10.1 Mqps) with batch size of 25, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.100us (10.0 Mqps) with batch size of 50, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.116us (8.6 Mqps) with batch size of 100, of found keys 83886080 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.189us (5.3 Mqps) with batch size of 0, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.095us (10.5 Mqps) with batch size of 10, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.096us (10.4 Mqps) with batch size of 25, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.098us (10.2 Mqps) with batch size of 50, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.105us (9.5 Mqps) with batch size of 100, of found keys 73400320 rocksdb] ./cuckoo_table_reader_test Test CuckooReaderTest.WhenKeyExists Test CuckooReaderTest.WhenKeyExistsWithUint64Comparator Test CuckooReaderTest.CheckIterator Test CuckooReaderTest.CheckIteratorUint64 Test CuckooReaderTest.WhenKeyNotFound Test CuckooReaderTest.TestReadPerformance With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.230us (4.3 Mqps) with batch size of 0, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.086us (11.7 Mqps) with batch size of 10, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.088us (11.3 Mqps) with batch size of 25, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.083us (12.1 Mqps) with batch size of 50, of found keys 125829120 With 125829120 items, utilization is 93.75%, number of hash functions: 2. Time taken per op is 0.083us (12.1 Mqps) with batch size of 100, of found keys 125829120 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.159us (6.3 Mqps) with batch size of 0, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.078us (12.8 Mqps) with batch size of 10, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.080us (12.6 Mqps) with batch size of 25, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.080us (12.5 Mqps) with batch size of 50, of found keys 104857600 With 104857600 items, utilization is 78.12%, number of hash functions: 2. Time taken per op is 0.082us (12.2 Mqps) with batch size of 100, of found keys 104857600 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.154us (6.5 Mqps) with batch size of 0, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.077us (13.0 Mqps) with batch size of 10, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.077us (12.9 Mqps) with batch size of 25, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.078us (12.8 Mqps) with batch size of 50, of found keys 83886080 With 83886080 items, utilization is 62.50%, number of hash functions: 2. Time taken per op is 0.079us (12.6 Mqps) with batch size of 100, of found keys 83886080 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.218us (4.6 Mqps) with batch size of 0, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.083us (12.0 Mqps) with batch size of 10, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.085us (11.7 Mqps) with batch size of 25, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.086us (11.6 Mqps) with batch size of 50, of found keys 73400320 With 73400320 items, utilization is 54.69%, number of hash functions: 2. Time taken per op is 0.078us (12.8 Mqps) with batch size of 100, of found keys 73400320 ``` Reviewers: sdong, igor, yhchiang Reviewed By: igor Subscribers: leveldb Differential Revision: Cuckoo Table Reader performance. Inlined hash function and number of buckets a power of two. Summary: Use inlined hash functions instead of function pointer. Make number of buckets a power of two and use bitwise and instead of mod. After these changes, we get almost 50% improvement in performance. Results: With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.231us (4.3 Mqps) with batch size of 0 Time taken per op is 0.229us (4.4 Mqps) with batch size of 0 Time taken per op is 0.185us (5.4 Mqps) with batch size of 0 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.108us (9.3 Mqps) with batch size of 10 Time taken per op is 0.100us (10.0 Mqps) with batch size of 10 Time taken per op is 0.103us (9.7 Mqps) with batch size of 10 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.101us (9.9 Mqps) with batch size of 25 Time taken per op is 0.098us (10.2 Mqps) with batch size of 25 Time taken per op is 0.097us (10.3 Mqps) with batch size of 25 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.100us (10.0 Mqps) with batch size of 50 Time taken per op is 0.097us (10.3 Mqps) with batch size of 50 Time taken per op is 0.097us (10.3 Mqps) with batch size of 50 With 120000000 items, utilization is 89.41%, number of hash functions: 2. Time taken per op is 0.102us (9.8 Mqps) with batch size of 100 Time taken per op is 0.098us (10.2 Mqps) with batch size of 100 Time taken per op is 0.115us (8.7 Mqps) with batch size of 100 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.201us (5.0 Mqps) with batch size of 0 Time taken per op is 0.155us (6.5 Mqps) with batch size of 0 Time taken per op is 0.152us (6.6 Mqps) with batch size of 0 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.089us (11.3 Mqps) with batch size of 10 Time taken per op is 0.084us (11.9 Mqps) with batch size of 10 Time taken per op is 0.086us (11.6 Mqps) with batch size of 10 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.087us (11.5 Mqps) with batch size of 25 Time taken per op is 0.085us (11.7 Mqps) with batch size of 25 Time taken per op is 0.093us (10.8 Mqps) with batch size of 25 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.094us (10.6 Mqps) with batch size of 50 Time taken per op is 0.094us (10.7 Mqps) with batch size of 50 Time taken per op is 0.093us (10.8 Mqps) with batch size of 50 With 100000000 items, utilization is 74.51%, number of hash functions: 2. Time taken per op is 0.092us (10.9 Mqps) with batch size of 100 Time taken per op is 0.089us (11.2 Mqps) with batch size of 100 Time taken per op is 0.088us (11.3 Mqps) with batch size of 100 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.154us (6.5 Mqps) with batch size of 0 Time taken per op is 0.168us (6.0 Mqps) with batch size of 0 Time taken per op is 0.190us (5.3 Mqps) with batch size of 0 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.081us (12.4 Mqps) with batch size of 10 Time taken per op is 0.077us (13.0 Mqps) with batch size of 10 Time taken per op is 0.083us (12.1 Mqps) with batch size of 10 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.077us (13.0 Mqps) with batch size of 25 Time taken per op is 0.073us (13.7 Mqps) with batch size of 25 Time taken per op is 0.073us (13.7 Mqps) with batch size of 25 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.076us (13.1 Mqps) with batch size of 50 Time taken per op is 0.072us (13.8 Mqps) with batch size of 50 Time taken per op is 0.072us (13.8 Mqps) with batch size of 50 With 80000000 items, utilization is 59.60%, number of hash functions: 2. Time taken per op is 0.077us (13.0 Mqps) with batch size of 100 Time taken per op is 0.074us (13.6 Mqps) with batch size of 100 Time taken per op is 0.073us (13.6 Mqps) with batch size of 100 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.190us (5.3 Mqps) with batch size of 0 Time taken per op is 0.186us (5.4 Mqps) with batch size of 0 Time taken per op is 0.184us (5.4 Mqps) with batch size of 0 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.079us (12.7 Mqps) with batch size of 10 Time taken per op is 0.070us (14.2 Mqps) with batch size of 10 Time taken per op is 0.072us (14.0 Mqps) with batch size of 10 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.080us (12.5 Mqps) with batch size of 25 Time taken per op is 0.072us (14.0 Mqps) with batch size of 25 Time taken per op is 0.071us (14.1 Mqps) with batch size of 25 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.082us (12.1 Mqps) with batch size of 50 Time taken per op is 0.071us (14.1 Mqps) with batch size of 50 Time taken per op is 0.073us (13.6 Mqps) with batch size of 50 With 70000000 items, utilization is 52.15%, number of hash functions: 2. Time taken per op is 0.080us (12.5 Mqps) with batch size of 100 Time taken per op is 0.077us (13.0 Mqps) with batch size of 100 Time taken per op is 0.078us (12.8 Mqps) with batch size of 100 Test Plan: make check all make valgrind_check make asan_check Reviewers: sdong, ljin Reviewed By: ljin Subscribers: leveldb Differential Revision: a user comparator for comparing Uint64 slices. Summary: New Uint64 comparator Modify Reader and Builder to take custom user comparators instead of bytewise comparator Modify logic for choosing unused user key in builder Modify iterator logic in reader test changes Test Plan: cuckoo_table_{builder,reader,db}_test make check all Reviewers: ljin, sdong Reviewed By: ljin Subscribers: dhruba, leveldb Differential Revision: Prepare method in CuckooTableReader Summary: Implement Prepare method Rewrite performance tests in cuckoo_table_reader_test to write new file only if one doesnt already exist. Add performance tests for batch lookup along with prefetching. Test Plan: ./cuckoo_table_reader_test Results (We get better results if we used int64 comparator instead of string comparator (TBD in future diffs)): With 100000000 items and hash table ratio 0.500000, number of hash functions used: 2. Time taken per op is 0.208us (4.8 Mqps) with batch size of 0 With 100000000 items and hash table ratio 0.500000, number of hash functions used: 2. Time taken per op is 0.182us (5.5 Mqps) with batch size of 10 With 100000000 items and hash table ratio 0.500000, number of hash functions used: 2. Time taken per op is 0.161us (6.2 Mqps) with batch size of 25 With 100000000 items and hash table ratio 0.500000, number of hash functions used: 2. Time taken per op is 0.161us (6.2 Mqps) with batch size of 50 With 100000000 items and hash table ratio 0.500000, number of hash functions used: 2. Time taken per op is 0.163us (6.1 Mqps) with batch size of 100 With 100000000 items and hash table ratio 0.600000, number of hash functions used: 3. Time taken per op is 0.252us (4.0 Mqps) with batch size of 0 With 100000000 items and hash table ratio 0.600000, number of hash functions used: 3. Time taken per op is 0.192us (5.2 Mqps) with batch size of 10 With 100000000 items and hash table ratio 0.600000, number of hash functions used: 3. Time taken per op is 0.195us (5.1 Mqps) with batch size of 25 With 100000000 items and hash table ratio 0.600000, number of hash functions used: 3. Time taken per op is 0.191us (5.2 Mqps) with batch size of 50 With 100000000 items and hash table ratio 0.600000, number of hash functions used: 3. Time taken per op is 0.194us (5.1 Mqps) with batch size of 100 With 100000000 items and hash table ratio 0.750000, number of hash functions used: 3. Time taken per op is 0.228us (4.4 Mqps) with batch size of 0 With 100000000 items and hash table ratio 0.750000, number of hash functions used: 3. Time taken per op is 0.185us (5.4 Mqps) with batch size of 10 With 100000000 items and hash table ratio 0.750000, number of hash functions used: 3. Time taken per op is 0.186us (5.4 Mqps) with batch size of 25 With 100000000 items and hash table ratio 0.750000, number of hash functions used: 3. Time taken per op is 0.189us (5.3 Mqps) with batch size of 50 With 100000000 items and hash table ratio 0.750000, number of hash functions used: 3. Time taken per op is 0.188us (5.3 Mqps) with batch size of 100 With 100000000 items and hash table ratio 0.900000, number of hash functions used: 3. Time taken per op is 0.325us (3.1 Mqps) with batch size of 0 With 100000000 items and hash table ratio 0.900000, number of hash functions used: 3. Time taken per op is 0.196us (5.1 Mqps) with batch size of 10 With 100000000 items and hash table ratio 0.900000, number of hash functions used: 3. Time taken per op is 0.199us (5.0 Mqps) with batch size of 25 With 100000000 items and hash table ratio 0.900000, number of hash functions used: 3. Time taken per op is 0.196us (5.1 Mqps) with batch size of 50 With 100000000 items and hash table ratio 0.900000, number of hash functions used: 3. Time taken per op is 0.209us (4.8 Mqps) with batch size of 100 Reviewers: sdong, yhchiang, igor, ljin Reviewed By: ljin Subscribers: leveldb Differential Revision:"
,,0.2708,rocksdb,"Added JSON manifest dump option to ldb command Summary: Added a new flag to the ldb manifest_dump command that prints out the version edits as JSON objects for easier reading and parsing of information. Test Plan: **Sample usage: ** ``` ./ldb manifest_dump ``` **Sample output:** ``` {""EditNumber"": 0, ""Comparator"": ""leveldb.BytewiseComparator"", ""ColumnFamily"": 0} {""EditNumber"": 1, ""LogNumber"": 0, ""ColumnFamily"": 0} {""EditNumber"": 2, ""LogNumber"": 4, ""PrevLogNumber"": 0, ""NextFileNumber"": 7, ""LastSeq"": 35356, ""AddedFiles"": [{""Level"": 0, ""FileNumber"": 5, ""FileSize"": 1949284, ""SmallestIKey"": """", ""LargestIKey"": """"}], ""ColumnFamily"": 0} ... {""EditNumber"": 13, ""PrevLogNumber"": 0, ""NextFileNumber"": 36, ""LastSeq"": 290994, ""DeletedFiles"": [{""Level"": 0, ""FileNumber"": 17}, {""Level"": 0, ""FileNumber"": 20}, {""Level"": 0, ""FileNumber"": 22}, {""Level"": 0, ""FileNumber"": 24}, {""Level"": 1, ""FileNumber"": 13}, {""Level"": 1, ""FileNumber"": 14}, {""Level"": 1, ""FileNumber"": 15}, {""Level"": 1, ""FileNumber"": 18}], ""AddedFiles"": [{""Level"": 1, ""FileNumber"": 25, ""FileSize"": 2114340, ""SmallestIKey"": """", ""LargestIKey"": """"}, {""Level"": 1, ""FileNumber"": 26, ""FileSize"": 2115213, ""SmallestIKey"": """", ""LargestIKey"": """"}, {""Level"": 1, ""FileNumber"": 27, ""FileSize"": 2114807, ""SmallestIKey"": """", ""LargestIKey"": """"}, {""Level"": 1, ""FileNumber"": 30, ""FileSize"": 2115271, ""SmallestIKey"": """", ""LargestIKey"": """"}, {""Level"": 1, ""FileNumber"": 31, ""FileSize"": 2115165, ""SmallestIKey"": """", ""LargestIKey"": """"}, {""Level"": 1, ""FileNumber"": 32, ""FileSize"": 2114683, ""SmallestIKey"": """", ""LargestIKey"": """"}, {""Level"": 1, ""FileNumber"": 35, ""FileSize"": 1757512, ""SmallestIKey"": """", ""LargestIKey"": """"}], ""ColumnFamily"": 0} ... ``` Reviewers: sdong, anthony, yhchiang, igor Reviewed By: igor Subscribers: dhruba Differential Revision:"
,,0.05,rocksdb,Fix formatting identified by `arc lint`/
,,0.05,rocksdb,Fix formatting identified by `arc lint`/
,,0.05,rocksdb,Fix formatting identified by `arc lint`/
,,0.05,rocksdb,Deprecate org.rocksdb.AbstractNativeReference#dispose() and implement java.lang.AutoCloseable/
,,0.05,rocksdb,Fix formatting identified by `arc lint`/
,,0.05,rocksdb,Fix formatting identified by `arc lint`/
,,0.05,rocksdb,Fix formatting identified by `arc lint`/
,,0.0726,rocksdb,"Fix Java Break Related to memtable bloom bits to size ratio change Summary: Need to change several more places for the change to fix Java tests Test Plan: make jtest under java, run ""make db_bench"" Reviewers: yhchiang, andrewkr, IslamAbdelRahman Reviewed By: IslamAbdelRahman Subscribers: leveldb, andrewkr, dhruba Differential Revision:"
,,0.2479,rocksdb,"Optimize sequential insert into memtable Part 1: Interface Summary: Currently our skip-list have an optimization to speedup sequential inserts from a single stream, by remembering the last insert position. We extend the idea to support sequential inserts from multiple streams, and even tolerate small reordering wihtin each stream. This PR is the interface part adding the following: Add `memtable_insert_prefix_extractor` to allow specifying prefix for each key. Add `InsertWithHint()` interface to memtable, to allow underlying implementation to return a hint of insert position, which can be later pass back to optimize inserts. Memtable will maintain a map from prefix to hints and pass the hint via `InsertWithHint()` if `memtable_insert_prefix_extractor` is non-null. Closes Differential Revision: D4079367 Pulled By: yiwu-arbug fbshipit-source-id: 3555326/"
,,0.3361,rocksdb,"Pinnableslice (2nd attempt) Summary: PinnableSlice Summary: Currently the point lookup values are copied to a string provided by the user. This incures an extra memcpy cost. This patch allows doing point lookup via a PinnableSlice which pins the source memory location (instead of copying their content) and releases them after the content is consumed by the user. The old API of Get(string) is translated to the new API underneath. Here is the summary for improvements: value 100 byte: 1.8% regular, 1.2% merge values value 1k byte: 11.5% regular, 7.5% merge values value 10k byte: 26% regular, 29.9% merge values The improvement for merge could be more if we extend this approach to pin the merge output and delay the full merge operation until the user actually needs it. We have put that for future work. PS: Sometimes we observe a small decrease in performance when switching from t5452014 to this patch but with the old Get(string) API. The d Closes Differential Revision: D4391738 Pulled By: maysamyabandeh fbshipit-source-id: 6f3edd3/"
,,0.1823,rocksdb,"unbiase readamp bitmap Summary: Consider BlockReadAmpBitmap with bytes_per_bit 32. Suppose bytes [a, b) were used, while bytes [a-32, a) and [b+1, b+33) werent used; more formally, the union of ranges passed to BlockReadAmpBitmap::Mark() contains [a, b) and doesnt intersect with [a-32, a) and [b+1, b+33). Then bits [floor(a/32), ceil(b/32)] will be set, and so the number of useful bytes will be estimated as (ceil(b/32) floor(a/32)) * 32, which is on average equal to b-a+31. An extreme example: if we use 1 byte from each block, itll be counted as 32 bytes from each block. Its easy to remove this bias by slightly changing the semantics of the bitmap. Currently each bit represents a byte range [i*32, (i+1)*32). This diff makes each bit represent a single byte: i*32 + X, where X is a random number in [0, 31] generated when bitmap is created. So, e.g., if you read a single byte at random, with probability 31/32 it wont be counted at all, and with probability 1/32 it will be counted as 32 bytes; so, on average its counted as 1 byte. *But there is one exception: the last bit will always set with the old way.* (*) assuming read_amp_bytes_per_bit 32. Closes Differential Revision: D5035652 Pulled By: lightmark fbshipit-source-id: bd98b1b9b49fbe61f9e3781d07f624e3cbd92356/"
,,0.1512,rocksdb,"Add C API functions (and tests) for WriteBatchWithIndex Summary: Ive added functions to the C API to support WriteBatchWithIndex as requested in Ive also added unit tests to c_test Ive implemented the WriteBatchWithIndex variation of every function available for regular WriteBatch. And added additional functions unique to WriteBatchWithIndex. For now, the following is omitted: 1. The ability to create WriteBatchWithIndexs custom batch-only iterator as Im not sure what its purpose is. It should be possible to add later if anyone wants it. 2. The ability to create the batch with a fallback comparator, since it appears to be unnecessary. I believe the column family comparator will be used for this, meaning those using a custom comparator can just use the column family variations. Closes Differential Revision: D4760039 Pulled By: siying fbshipit-source-id: 393227e/"
,,0.3346,rocksdb,"Reduce the number of params needed to construct DBIter Summary: DBIter, and in-turn NewDBIterator and NewArenaWrappedDBIterator, take a bunch of params. They can be reduced by passing in ReadOptions directly instead of passing in every new param separately. It also seems much cleaner as a bunch of the params towards the end seem to be optional. (Recently I introduced max_skippable_internal_keys, which added one more to the already huge count). Idea courtesy IslamAbdelRahman Closes Differential Revision: D4857128 Pulled By: sagar0 fbshipit-source-id: 7d239df094b94bd9ea79d145cdf825478ac037a8/Pinnableslice (2nd attempt) Summary: PinnableSlice Summary: Currently the point lookup values are copied to a string provided by the user. This incures an extra memcpy cost. This patch allows doing point lookup via a PinnableSlice which pins the source memory location (instead of copying their content) and releases them after the content is consumed by the user. The old API of Get(string) is translated to the new API underneath. Here is the summary for improvements: value 100 byte: 1.8% regular, 1.2% merge values value 1k byte: 11.5% regular, 7.5% merge values value 10k byte: 26% regular, 29.9% merge values The improvement for merge could be more if we extend this approach to pin the merge output and delay the full merge operation until the user actually needs it. We have put that for future work. PS: Sometimes we observe a small decrease in performance when switching from t5452014 to this patch but with the old Get(string) API. The d Closes Differential Revision: D4391738 Pulled By: maysamyabandeh fbshipit-source-id: 6f3edd3/"
,,0.3058,rocksdb,"Pinnableslice (2nd attempt) Summary: PinnableSlice Summary: Currently the point lookup values are copied to a string provided by the user. This incures an extra memcpy cost. This patch allows doing point lookup via a PinnableSlice which pins the source memory location (instead of copying their content) and releases them after the content is consumed by the user. The old API of Get(string) is translated to the new API underneath. Here is the summary for improvements: value 100 byte: 1.8% regular, 1.2% merge values value 1k byte: 11.5% regular, 7.5% merge values value 10k byte: 26% regular, 29.9% merge values The improvement for merge could be more if we extend this approach to pin the merge output and delay the full merge operation until the user actually needs it. We have put that for future work. PS: Sometimes we observe a small decrease in performance when switching from t5452014 to this patch but with the old Get(string) API. The d Closes Differential Revision: D4391738 Pulled By: maysamyabandeh fbshipit-source-id: 6f3edd3/Statistic for how often rate limiter is drained Summary: This is the metric I plan to use for adaptive rate limiting. The statistics are updated only if the rate limiter is drained by flush or compaction. I believe (but am not certain) that this is the normal case. The Statistics object is passed in RateLimiter::Request() to avoid requiring changes to client code, which wouldve been necessary if we passed it in the RateLimiter constructor. Closes Differential Revision: D4646489 Pulled By: ajkr fbshipit-source-id: d8e0161/"
,,0.1586,rocksdb,"Add C API functions (and tests) for WriteBatchWithIndex Summary: Ive added functions to the C API to support WriteBatchWithIndex as requested in Ive also added unit tests to c_test Ive implemented the WriteBatchWithIndex variation of every function available for regular WriteBatch. And added additional functions unique to WriteBatchWithIndex. For now, the following is omitted: 1. The ability to create WriteBatchWithIndexs custom batch-only iterator as Im not sure what its purpose is. It should be possible to add later if anyone wants it. 2. The ability to create the batch with a fallback comparator, since it appears to be unnecessary. I believe the column family comparator will be used for this, meaning those using a custom comparator can just use the column family variations. Closes Differential Revision: D4760039 Pulled By: siying fbshipit-source-id: 393227e/"
,,0.1267,rocksdb,"Java wrapper for Native Comparators Summary: This is an abstraction for working with custom Comparators implemented in native C++ code from Java. Native code must directly extend `rocksdb::Comparator`. When the native code comparator is compiled into the RocksDB codebase, you can then create a Java Class, and JNI stub to wrap it. Useful if the C++/JNI barrier overhead is too much for your applications comparator performance. An example is provided in `java/rocksjni/native_comparator_wrapper_test.cc` and `java/src/main/java/org/rocksdb/NativeComparatorWrapperTest.java`. Closes Differential Revision: D7172605 Pulled By: miasantreble fbshipit-source-id: e24b7eb267a3bcb6afa214e0379a1d5e8a2ceabe/"
,,0.1296,rocksdb,"Java wrapper for Native Comparators Summary: This is an abstraction for working with custom Comparators implemented in native C++ code from Java. Native code must directly extend `rocksdb::Comparator`. When the native code comparator is compiled into the RocksDB codebase, you can then create a Java Class, and JNI stub to wrap it. Useful if the C++/JNI barrier overhead is too much for your applications comparator performance. An example is provided in `java/rocksjni/native_comparator_wrapper_test.cc` and `java/src/main/java/org/rocksdb/NativeComparatorWrapperTest.java`. Closes Differential Revision: D7172605 Pulled By: miasantreble fbshipit-source-id: e24b7eb267a3bcb6afa214e0379a1d5e8a2ceabe/"
,,0.13699999999999998,rocksdb,"Java wrapper for Native Comparators Summary: This is an abstraction for working with custom Comparators implemented in native C++ code from Java. Native code must directly extend `rocksdb::Comparator`. When the native code comparator is compiled into the RocksDB codebase, you can then create a Java Class, and JNI stub to wrap it. Useful if the C++/JNI barrier overhead is too much for your applications comparator performance. An example is provided in `java/rocksjni/native_comparator_wrapper_test.cc` and `java/src/main/java/org/rocksdb/NativeComparatorWrapperTest.java`. Closes Differential Revision: D7172605 Pulled By: miasantreble fbshipit-source-id: e24b7eb267a3bcb6afa214e0379a1d5e8a2ceabe/"
,,0.2111,rocksdb,"Propagate fill_cache config to partitioned index iterator Summary: Currently the partitioned index iterator creates a new ReadOptions which ignores the fill_cache config set to ReadOptions passed by the user. The patch propagates fill_cache from the users ReadOptions to that of partition index iterator. Also it clarifies the contract of fill_cache that i) it does not apply to filters, ii) it still charges block cache for the size of the data block, it still pin the block if it is already in the block cache. Closes Differential Revision: D7678308 Pulled By: maysamyabandeh fbshipit-source-id: 53ed96424ae922e499e2d4e3580ddc3f0db893da/Stats for false positive rate of full filtesr Summary: Adds two stats to allow us measuring the false positive rate of full filters: The total count of positives: rocksdb.bloom.filter.full.positive The total count of true positives: rocksdb.bloom.filter.full.true.positive Not the term ""full"" in the stat name to indicate that they are meaningful in full filters. block-based filters are to be deprecated soon and supporting it is not worth the the additional cost of if-then-else branches. Closes Tested by: $ ./db_bench /dev/shm/rocksdb-tmpdb $ ./db_bench /dev/shm/rocksdb-tmpdb 2>&1 > /tmp/full.log $ grep filter.full /tmp/full.log rocksdb.bloom.filter.full.positive COUNT : 3628593 rocksdb.bloom.filter.full.true.positive COUNT : 3536026 which gives the false positive rate of 2.5% Closes Differential Revision: D7517570 Pulled By: maysamyabandeh fbshipit-source-id: 630ab1a473afdce404916d297035b6318de4c052/uint64_t and size_t changes to compile for iOS Summary: In attempting to build a static lib for use in iOS, I ran in to lots of type errors between uint64_t and size_t. This PR contains the changes I made to get `TARGET_OS=IOS make static_lib` to succeed while also getting Xcode to build successfully with the resulting `librocksdb.a` library imported. This also compiles for me on macOS and tests fine, but Im really not sure if I made the correct decisions about where to `static_cast` and where to change types. Also up for discussion: is iOS worth supporting? Getting the static lib is just part one, we arent providing any bridging headers or wrappers like the ObjectiveRocks project, it wont be a great experience. Closes Differential Revision: D7106457 Pulled By: gfosco fbshipit-source-id: 82ac2073de7e1f09b91f6b4faea91d18bd311f8e/Comment out unused variables Summary: Submitting on behalf of another employee. Closes Differential Revision: D7146025 Pulled By: ajkr fbshipit-source-id: 495ca5db5beec3789e671e26f78170957704e77e/Customized BlockBasedTableIterator and LevelIterator Summary: Use a customzied BlockBasedTableIterator and LevelIterator to replace current implementations leveraging two-level-iterator. Hope the customized logic will make code easier to understand. As a side effect, BlockBasedTableIterator reduces the allocation for the data block iterator object, and avoid the virtual function call to it, because we can directly reference BlockIter, a final class. Similarly, LevelIterator reduces virtual function call to the dummy iterator iterating the file metadata. It also enabled further optimization. The upper bound check is also moved from index block to data block. This implementation fits this iterator better. After the change, forwared iterator is slightly optimized to ensure we trim those iterators. The two-level-iterator now is only used by partitioned index, so it is simplified. Closes Differential Revision: D6809041 Pulled By: siying fbshipit-source-id: 7da3b9b1d3c8e9d9405302c15920af1fcaf50ffa/"
,,0.3413,rocksdb,"Stats for false positive rate of full filtesr Summary: Adds two stats to allow us measuring the false positive rate of full filters: The total count of positives: rocksdb.bloom.filter.full.positive The total count of true positives: rocksdb.bloom.filter.full.true.positive Not the term ""full"" in the stat name to indicate that they are meaningful in full filters. block-based filters are to be deprecated soon and supporting it is not worth the the additional cost of if-then-else branches. Closes Tested by: $ ./db_bench /dev/shm/rocksdb-tmpdb $ ./db_bench /dev/shm/rocksdb-tmpdb 2>&1 > /tmp/full.log $ grep filter.full /tmp/full.log rocksdb.bloom.filter.full.positive COUNT : 3628593 rocksdb.bloom.filter.full.true.positive COUNT : 3536026 which gives the false positive rate of 2.5% Closes Differential Revision: D7517570 Pulled By: maysamyabandeh fbshipit-source-id: 630ab1a473afdce404916d297035b6318de4c052/"
,,0.1884,rocksdb,"Consolidate hash function used for non-persistent data in a new function (#5155) Summary: Create new function NPHash64() and GetSliceNPHash64(), which are currently implemented using murmurhash. Replace the current direct call of murmurhash() to use the new functions if the hash results are not used in on-disk format. This will make it easier to try out or switch to alternative functions in the uses where data format compatibility doesnt need to be considered. This part shouldnt have any performance impact. Also, the sharded cache hash function is changed to the new format, because it falls into this categoery. It doesnt show visible performance impact in db_bench results. CPU showed by perf is increased from about 0.2% to 0.4% in an extreme benchmark setting (4KB blocks, no-compression, everything cached in block cache). Weve known that the current hash function used, our own Hash() has serious hash quality problem. It can generate a lots of conflicts with similar input. In this use case, it means extra lock contention for reads from the same file. This slight CPU regression is worthy to me to counter the potential bad performance with hot keys. And hopefully this will get further improved in the future with a better hash function. cache_tests condition is relaxed a little bit to. The new hash is slightly more skewed in this use case, but I manually checked the data and see the hash results are still in a reasonable range. Pull Request resolved: Differential Revision: D14834821 Pulled By: siying fbshipit-source-id: ec9a2c0a2f8ae4b54d08b13a5c2e9cc97aa80cb5/"
,,0.341,rocksdb,"Misc hashing updates / upgrades (#5909) Summary: Updated our included xxhash implementation to version 0.7.2 (== the latest dev version as of 2019-10-09). Using XXH_NAMESPACE (like other fb projects) to avoid potential name collisions. Added fastrange64, and unit tests for it and fastrange32. These are faster alternatives to hash % range. Use preview version of XXH3 instead of MurmurHash64A for NPHash64 Had to update cache_test to increase probability of passing for any given hash function. Use fastrange64 instead of % with uses of NPHash64 Had to fix WritePreparedTransactionTest.CommitOfDelayedPrepared to avoid deadlock apparently caused by new hash collision. Set default seed for NPHash64 because specifying a seed rarely makes sense for it. Removed unnecessary include xxhash.h in a popular .h file Rename preview version of XXH3 to XXH3p for clarity and to ease backward compatibility in case final version of XXH3 is integrated. Relying on existing unit tests for NPHash64-related changes. Each new implementation of fastrange64 passed unit tests when manipulating my local build to select it. I havent done any integration performance tests, but I consider the improved performance of the pieces being swapped in to be well established. Pull Request resolved: Differential Revision: D18125196 Pulled By: pdillinger fbshipit-source-id: f6bf83d49d20cbb2549926adf454fd035f0ecc0d/"
,,0.4769,rocksdb,"Misc hashing updates / upgrades (#5909) Summary: Updated our included xxhash implementation to version 0.7.2 (== the latest dev version as of 2019-10-09). Using XXH_NAMESPACE (like other fb projects) to avoid potential name collisions. Added fastrange64, and unit tests for it and fastrange32. These are faster alternatives to hash % range. Use preview version of XXH3 instead of MurmurHash64A for NPHash64 Had to update cache_test to increase probability of passing for any given hash function. Use fastrange64 instead of % with uses of NPHash64 Had to fix WritePreparedTransactionTest.CommitOfDelayedPrepared to avoid deadlock apparently caused by new hash collision. Set default seed for NPHash64 because specifying a seed rarely makes sense for it. Removed unnecessary include xxhash.h in a popular .h file Rename preview version of XXH3 to XXH3p for clarity and to ease backward compatibility in case final version of XXH3 is integrated. Relying on existing unit tests for NPHash64-related changes. Each new implementation of fastrange64 passed unit tests when manipulating my local build to select it. I havent done any integration performance tests, but I consider the improved performance of the pieces being swapped in to be well established. Pull Request resolved: Differential Revision: D18125196 Pulled By: pdillinger fbshipit-source-id: f6bf83d49d20cbb2549926adf454fd035f0ecc0d/Faster new DynamicBloom implementation (for memtable) (#5762) Summary: Since DynamicBloom is now only used in-memory, were free to change it without schema compatibility issues. The new implementation is drawn from (with manifest permission) This has several speed advantages over the prior implementation: * Uses fastrange instead of % * Minimum logic to determine first (and all) probed memory addresses * (Major) Two probes per 64-bit memory fetch/write. * Very fast and effective (murmur-like) hash expansion/re-mixing. (At least on recent CPUs, integer multiplication is very cheap.) While a Bloom filter with 512-bit cache locality has about a 1.15x FP rate penalty (e.g. 0.84% to 0.97%), further restricting to two probes per 64 bits incurs an additional 1.12x FP rate penalty (e.g. 0.97% to 1.09%). Nevertheless, the unit tests show no ""mediocre"" FP rate samples, unlike the old implementation with more erratic FP rates. Especially for the memtable, we expect speed to outweigh somewhat higher FP rates. For example, a negative table query would have to be 1000x slower than a BF query to justify doubling BF query time to shave 10% off FP rate (working assumption around 1% FP rate). While that seems likely for SSTs, my data suggests a speed factor of roughly 50x for the memtable (vs. BF; ~1.5% lower write throughput when enabling memtable Bloom filter, after this change). Thus, its probably not worth even 5% more time in the Bloom filter to shave off 1/10th of the Bloom FP rate, or 0.1% in absolute terms, and its probably at least 20% slower to recoup that much FP rate from this new implementation. Because of this, we do not see a need for a locality option that affects the MemTable Bloom filter and have decoupled the MemTable Bloom filter from Options::bloom_locality. Note that just 3% more memory to the Bloom filter (10.3 bits per key vs. just 10) is able to make up for the ~12% FP rate drop in the new implementation: [] Nearly ""ideal"" FP-wise but reasonably fast cache-local implementation [~/wormhashing/bloom_simulation_tests] ./foo_gcc_IMPL_CACHE_WORM64_FROM32_any.out 10000000 6 10 $RANDOM 100000000 ./foo_gcc_IMPL_CACHE_WORM64_FROM32_any.out time: 3.29372 sampled_fp_rate: 0.00985956 ... [] Close match to this new implementation [~/wormhashing/bloom_simulation_tests] ./foo_gcc_IMPL_CACHE_MUL64_BLOCK_FROM32_any.out 10000000 6 10.3 $RANDOM 100000000 ./foo_gcc_IMPL_CACHE_MUL64_BLOCK_FROM32_any.out time: 2.10072 sampled_fp_rate: 0.00985655 ... [] Old locality=1 implementation [~/wormhashing/bloom_simulation_tests] ./foo_gcc_IMPL_CACHE_ROCKSDB_DYNAMIC_any.out 10000000 6 10 $RANDOM 100000000 ./foo_gcc_IMPL_CACHE_ROCKSDB_DYNAMIC_any.out time: 3.95472 sampled_fp_rate: 0.00988943 ... Also note the dramatic speed improvement vs. alternatives. Performance unit test: DynamicBloomTest.concurrent_with_perf is updated to report more precise timing data. (Measure running time of each thread, not just longest running thread, etc.) Results averaged over various sizes enabled with and 20 runs each; old dynamic bloom refers to locality=1, the faster of the old: old dynamic bloom, avg add latency 65.6468 new dynamic bloom, avg add latency 44.3809 old dynamic bloom, avg query latency 50.6485 new dynamic bloom, avg query latency 43.2186 old avg parallel add latency 41.678 new avg parallel add latency 24.5238 old avg parallel hit latency 14.6322 new avg parallel hit latency 12.3939 old avg parallel miss latency 16.7289 new avg parallel miss latency 12.2134 Tested on a dedicated 64-bit production machine at Facebook. Significant improvement all around. Despite now using std::atomic<uint64_t>, quick before-and-after test on a 32-bit machine (Intel Atom N270, released 2008) shows no regression in performance, in some cases modest improvement. Performance integration test (synthetic): with DEBUG_LEVEL=0, used TEST_TMPDIR=/dev/shm ./db_bench and optionally with 300 runs each configuration. Write throughput change by enabling memtable bloom: Old locality=0: Old locality=1: New: conclusion seems to substantially close the gap Readmissing throughput change by enabling memtable bloom: Old locality=0: +34.47% Old locality=1: +34.80% New: +33.25% conclusion maybe a small new penalty from FP rate Readrandom throughput change by enabling memtable bloom: Old locality=0: +31.54% Old locality=1: +31.13% New: +30.60% conclusion maybe also from FP rate (after memtable flush) Another conclusion we can draw from this new implementation is that the existing 32-bit hash function is not inherently crippling the Bloom filter speed or accuracy, below about 5 million keys. For speed, the implementation is essentially the same whether starting with 32-bits or 64-bits of hash; it just determines whether the first multiplication after fastrange is a pseudorandom expansion or needed re-mix. Note that this multiplication can occur while memory is fetching. For accuracy, in a standard configuration, you need about 5 million keys before you have about a 1.1x FP penalty due to using a 32-bit hash vs. 64-bit: [~/wormhashing/bloom_simulation_tests] ./foo_gcc_IMPL_CACHE_MUL64_BLOCK_FROM32_any.out $((5 * 1000 * 1000 * 10)) 6 10 $RANDOM 100000000 ./foo_gcc_IMPL_CACHE_MUL64_BLOCK_FROM32_any.out time: 2.52069 sampled_fp_rate: 0.0118267 ... [~/wormhashing/bloom_simulation_tests] ./foo_gcc_IMPL_CACHE_MUL64_BLOCK_any.out $((5 * 1000 * 1000 * 10)) 6 10 $RANDOM 100000000 ./foo_gcc_IMPL_CACHE_MUL64_BLOCK_any.out time: 2.43871 sampled_fp_rate: 0.0109059 Pull Request resolved: Differential Revision: D17214194 Pulled By: pdillinger fbshipit-source-id: ad9da031772e985fd6b62a0e1db8e81892520595/"
